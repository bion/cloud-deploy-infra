#! /usr/bin/env bash

# Grants all database and public schema privilages on "postgres" to the service account user.
# If this fails the server will crashloop when it's unable to create tables or enable extensions.
# This script is janky, the thing that needs more investigating for more robust automation is how
# to grant permissions using something other than the default "postgres" user that requires
# password-based auth. I suppose at worst something similar to this script will run on a privileged
# pod in the saas control plane.

set -e

if [ $# -ne 2 ]; then
  echo "Need two arguments: DB_CONNECTION_NAME SERVICE_ACCOUNT_POSTGRES_USERNAME"
  echo "For example: ./service_account_db_grants sandbox-project:us-central1:civiform-tenant-bham civiform-tenant-sa-bham@sandbox-project.iam"
  exit 1
fi

DB_CONNECTION_NAME="${1}"
SA_PG_USERNAME="${2}"
# The instance name is the last portion of the connection name after splitting on :
DB_INSTANCE_NAME=$(echo "${DB_CONNECTION_NAME##*:}")

# Generate a random password
PASSWORD="$(echo $RANDOM | md5sum | head -c 30)"

# Set the postgres user's password to the one we just generated
gcloud sql users set-password postgres --instance="${DB_INSTANCE_NAME}" --password="${PASSWORD}"

# Start a local proxy to securely tunnel traffic from the local machine to the DB instance
cloud-sql-proxy "${DB_CONNECTION_NAME}" &
PROXY_PID=$!
echo "Proxy PID: ${PROXY_PID}"
# Give the proxy a few seconds to start or psql will fail on "Connection refused" i.e. nobody home
sleep 3

# Make sure we cleanup the proxy regardless of how the rest of this goes
cleanup() {
  kill "${PROXY_PID}"
}

trap cleanup ERR

printf "\nAdding grants for ${SA_PG_USERNAME}...\n\n"

PGPASSWORD="${PASSWORD}" psql \
  -h 127.0.0.1 \
  -U postgres \
  -c "GRANT ALL PRIVILEGES ON DATABASE postgres TO \"${SA_PG_USERNAME}\"; GRANT ALL PRIVILEGES ON SCHEMA public TO \"${SA_PG_USERNAME}\";" \
  postgres

printf "\nGrants added!\n\n"

cleanup
